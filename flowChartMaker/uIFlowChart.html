<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>We1 | UI FlowChart</title>
  <link rel="icon" href="../logo.png" type="image/x-icon">
  <!-- Bootstrap & Font Awesome -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">

  <!-- Konva & jsPDF -->
  <script src="https://cdn.jsdelivr.net/npm/konva@9/konva.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

  <style>
    :root {
      --sidebar-w: 280px;
      --topbar-h: 56px;
    }
    html, body {
      height: 100%;
      margin: 0;
      background: #f4f6f9;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, sans-serif;
    }
    .app-shell {
      display: grid;
      grid-template-rows: var(--topbar-h) 1fr;
      height: 100vh;
    }
    .topbar {
      background: #111827;
      color: #fff;
      box-shadow: 0 2px 8px rgba(0,0,0,0.25);
      z-index: 20;
    }
    .workspace {
      display: grid;
      grid-template-columns: var(--sidebar-w) 1fr;
      min-height: 0; /* allow children to shrink */
    }
    /* Sidebar */
    #sidebar {
      background: #1f2937;
      color: #e5e7eb;
      padding: 14px;
      overflow-y: auto;
      box-shadow: 2px 0 12px rgba(0,0,0,0.2);
    }
    #sidebar h6 {
      margin: 14px 0 8px;
      text-transform: uppercase;
      font-size: 12px;
      letter-spacing: .08em;
      opacity: .85;
    }
    .tool-btn {
      width: 100%;
      text-align: left;
      background: #2a3443;
      color: #e5e7eb;
      border: none;
      padding: 10px 12px;
      border-radius: 10px;
      margin: 5px 0;
      display: flex;
      align-items: center;
      gap: 10px;
      transition: background .2s, transform .08s;
      cursor: pointer;
    }
    .tool-btn:hover { background: #334155; transform: translateY(-1px); }
    .tool-btn.active { outline: 2px solid #60a5fa; background: #1e293b; }
    .tool-row { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
    .subtle {
      font-size: 12px;
      opacity: .8;
    }
    /* Canvas container */
    #canvasWrap {
      position: relative;
      overflow: hidden;
      background: repeating-conic-gradient(#fafafa 0% 25%, #f6f6f6 0% 50%) 50% / 32px 32px;
    }
    #container {
      width: 100%;
      height: 100%;
    }
    /* Floating hint */
    .hint {
      position: absolute;
      bottom: 12px;
      right: 12px;
      background: rgba(17,24,39,0.85);
      color: #e5e7eb;
      padding: 8px 12px;
      border-radius: 10px;
      font-size: 12px;
      pointer-events: none;
    }
    /* Label editing */
    .label-edit-overlay {
      position: absolute;
      background: white;
      border: 2px solid #3b82f6;
      border-radius: 6px;
      padding: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      z-index: 1000;
    }
    .label-edit-input {
      border: none;
      outline: none;
      background: transparent;
      font-size: 14px;
      min-width: 100px;
    }
  </style>
</head>
<body>
  <div class="app-shell">
    <!-- Top bar -->
    <nav class="navbar navbar-dark topbar px-3">
      <div class="d-flex align-items-center gap-2">
        <span class="navbar-brand fw-bold" style="display: flex;align-items: center;gap: 10px;">
          <img src="../logo.png" width="30" style="background: #ff000082;padding: 1px;border-radius: 5px;" />
          <span>UI FlowChart</span>
        </span>
      </div>
      <div class="d-flex align-items-center gap-2 ms-auto">
        <div class="btn-group" role="group" aria-label="Zoom">
          <button id="zoomOutBtn" class="btn btn-sm btn-outline-light"><i class="fa-solid fa-magnifying-glass-minus"></i></button>
          <button id="resetViewBtn" class="btn btn-sm btn-outline-light"><i class="fa-solid fa-up-right-and-down-left-from-center"></i></button>
          <button id="zoomInBtn" class="btn btn-sm btn-outline-light"><i class="fa-solid fa-magnifying-glass-plus"></i></button>
        </div>
        <button id="modeBtn" class="btn btn-sm btn-primary ms-2">
          <i class="fa-solid fa-arrow-right-arrow-left me-1"></i>
          <span>Connect Mode: Off</span>
        </button>
      </div>
    </nav>

    <!-- Workspace -->
    <div class="workspace">
      <!-- Sidebar -->
      <aside id="sidebar">
        <div class="mb-2 d-flex align-items-center gap-2">
          <i class="fa-solid fa-toolbox"></i>
          <strong>Tools</strong>
        </div>

        <h6>Shapes</h6>
        <div class="tool-row">
          <button class="tool-btn" onclick="addShape('rect')"><i class="fa-regular fa-square"></i>Rect</button>
          <button class="tool-btn" onclick="addShape('circle')"><i class="fa-regular fa-circle"></i>Circle</button>
          <button class="tool-btn" onclick="addShape('diamond')"><i class="fa-regular fa-gem"></i>Diamond</button>
          <button class="tool-btn" onclick="addShape('triangle')"><i class="fa-solid fa-caret-up fa-rotate-90"></i>Triangle</button>
          <button class="tool-btn" onclick="addShape('trapezoid')"><i class="fa-solid fa-draw-polygon"></i>Trapezoid</button>
          <button class="tool-btn" onclick="addShape('hexagon')"><i class="fa-regular fa-stop"></i>Hexagon</button>
        </div>

        <div class="mt-2">
          <label class="form-label subtle mb-1">Add Image</label>
          <input type="file" id="imgUpload" class="form-control form-control-sm">
        </div>

        <h6 class="mt-3">Connectors</h6>
        <div class="tool-row">
          <button class="tool-btn" onclick="setArrowStyle('solid')"><i class="fa-solid fa-minus"></i>Solid</button>
          <button class="tool-btn" onclick="setArrowStyle('dashed')"><i class="fa-solid fa-ellipsis"></i>Dashed</button>
          <button class="tool-btn" onclick="setArrowStyle('bold')"><i class="fa-solid fa-grip-lines"></i>Bold</button>
          <button class="tool-btn" onclick="setArrowStyle('double')"><i class="fa-solid fa-left-right"></i>Double</button>
          <button class="tool-btn" onclick="setArrowStyle('animated')"><i class="fa-solid fa-forward"></i>Animated</button>
        </div>
        <div class="subtle mt-1">Tip: Toggle "Connect Mode" in the top bar, then click two nodes to connect.</div>

        <h6 class="mt-3">Export / Import</h6>
        <div class="tool-row">
          <button class="tool-btn" onclick="exportPNG()"><i class="fa-regular fa-file-image"></i>PNG</button>
          <button class="tool-btn" onclick="exportSVG()"><i class="fa-solid fa-code"></i>SVG</button>
          <button class="tool-btn" onclick="exportPDF()"><i class="fa-regular fa-file-pdf"></i>PDF</button>
          <button class="tool-btn" onclick="exportJSON()"><i class="fa-regular fa-circle-down"></i>JSON</button>
        </div>
        <div class="mt-2">
          <label class="form-label subtle mb-1">Import JSON</label>
          <input type="file" id="importJson" class="form-control form-control-sm">
        </div>
      </aside>

      <!-- Canvas -->
      <section id="canvasWrap">
        <div id="container"></div>
        <div class="hint">
          <div><b>Pan:</b> drag empty space · <b>Zoom:</b> wheel</div>
          <div><b>Select:</b> click · <b>Resize/Rotate:</b> drag handles · <b>Delete:</b> Del</div>
          <div><b>Label:</b> double-click shape or connector</div>
        </div>
      </section>
    </div>
  </div>

  <script>
    let stage, layer, transformer, background;
    let isConnectMode = false;
    let arrowStartNode = null;
    let currentArrowStyle = "solid";
    let connections = []; // { fromId, toId, arrowId, labelId? }
    let idCounter = 1;

    const containerEl = document.getElementById('container');
    const canvasWrap = document.getElementById('canvasWrap');
    const modeBtn = document.getElementById('modeBtn');
    const modeText = modeBtn.querySelector('span');

    // --- Stage init ---
    function initStage() {
      if (stage) stage.destroy();

      stage = new Konva.Stage({
        container: 'container',
        width: canvasWrap.clientWidth,
        height: canvasWrap.clientHeight
      });

      layer = new Konva.Layer();
      stage.add(layer);

      // Background rect for panning capture
      background = new Konva.Rect({
        x: 0, y: 0,
        width: stage.width(),
        height: stage.height(),
        fill: 'rgba(0,0,0,0)',
        listening: true
      });
      layer.add(background);

      // Pan
      let isPanning = false;
      let lastPos = null;
      background.on('mousedown touchstart', (e) => {
        isPanning = true;
        lastPos = stage.getPointerPosition();
      });
      stage.on('mouseup touchend', () => { isPanning = false; });
      stage.on('mousemove touchmove', () => {
        if (!isPanning) return;
        const pos = stage.getPointerPosition();
        const dx = pos.x - lastPos.x;
        const dy = pos.y - lastPos.y;
        stage.x(stage.x() + dx);
        stage.y(stage.y() + dy);
        stage.batchDraw();
        lastPos = pos;
      });

      // Zoom
      containerEl.addEventListener('wheel', (e) => {
        e.preventDefault();
        const scaleBy = 1.05;
        const oldScale = stage.scaleX();
        const mousePoint = stage.getPointerPosition();

        const direction = e.deltaY > 0 ? -1 : 1;
        const newScale = direction > 0 ? oldScale * scaleBy : oldScale / scaleBy;
        const pointer = {
          x: (mousePoint.x - stage.x()) / oldScale,
          y: (mousePoint.y - stage.y()) / oldScale
        };

        stage.scale({ x: newScale, y: newScale });
        const newPos = {
          x: mousePoint.x - pointer.x * newScale,
          y: mousePoint.y - pointer.y * newScale
        };
        stage.position(newPos);
        stage.batchDraw();
      }, { passive: false });

      // Delete selected node
      window.addEventListener('keydown', (e) => {
        if (e.key === 'Delete' && transformer?.nodes()[0]) {
          const node = transformer.nodes()[0];
          removeNodeAndConnections(node);
        }
      });
    }

    function nextId(prefix='node') {
      return `${prefix}-${idCounter++}`;
    }

    function makeSelectableAndDraggable(node) {
      node.draggable(true);
      node.on('click', (evt) => {
        evt.cancelBubble = true; // prevent stage click
        if (isConnectMode) {
          handleConnectClick(node);
        } else {
          enableTransformer(node);
        }
      });
      
      // Add double-click for label editing
      node.on('dblclick', (evt) => {
        evt.cancelBubble = true;
        editNodeLabel(node);
      });
      
      node.on('dragmove', () => updateConnectionsFor(node));
      node.on('transform', () => updateConnectionsFor(node));
      node.on('transformend', () => updateConnectionsFor(node));
      layer.add(node);
      layer.draw();
    }

    function enableTransformer(node) {
      if (transformer) transformer.destroy();
      transformer = new Konva.Transformer({
        nodes: [node],
        rotateEnabled: true,
        enabledAnchors: ['top-left','top-right','bottom-left','bottom-right'],
        ignoreStroke: false,
        boundBoxFunc: (oldBox, newBox) => {
          if (newBox.width < 30 || newBox.height < 30) return oldBox;
          return newBox;
        }
      });
      layer.add(transformer);
      layer.draw();
    }

    function addShape(type) {
      let shape;
      if (type==='rect') {
        shape = new Konva.Rect({
          id: nextId('rect'),
          x: 120, y: 120, width: 140, height: 70,
          fill: '#93c5fd', stroke: '#111827', strokeWidth: 2
        });
      }
      if (type==='circle') {
        shape = new Konva.Circle({
          id: nextId('circle'),
          x: 260, y: 220, radius: 55,
          fill: '#f9a8d4', stroke: '#111827', strokeWidth: 2
        });
      }
      if (type==='diamond') {
        shape = new Konva.RegularPolygon({
          id: nextId('diamond'),
          x: 420, y: 160, sides: 4, radius: 70, rotation: 45,
          fill: '#fb923c', stroke: '#111827', strokeWidth: 2
        });
      }
      if (type==='triangle') {
        shape = new Konva.RegularPolygon({
          id: nextId('triangle'),
          x: 600, y: 160, sides: 3, radius: 65,
          fill: '#86efac', stroke: '#111827', strokeWidth: 2
        });
      }
      if (type==='trapezoid') {
        shape = new Konva.Line({
          id: nextId('trapezoid'),
          points:[0,60,50,0,150,0,200,60],
          x: 720, y: 200,
          fill:'#a78bfa', stroke:'#111827', strokeWidth:2, closed:true
        });
      }
      if (type==='hexagon') {
        shape = new Konva.RegularPolygon({
          id: nextId('hexagon'),
          x: 880, y: 160, sides: 6, radius: 60,
          fill: '#facc15', stroke:'#111827', strokeWidth:2
        });
      }

      if (shape) makeSelectableAndDraggable(shape);
    }

    // --- Label editing for shapes ---
    function editNodeLabel(node) {
      const pos = node.getAbsolutePosition();
      const stageBox = stage.container().getBoundingClientRect();
      
      const input = document.createElement('input');
      input.className = 'label-edit-input';
      input.value = node.getAttr('label') || '';
      input.placeholder = 'Enter label...';
      
      const overlay = document.createElement('div');
      overlay.className = 'label-edit-overlay';
      overlay.appendChild(input);
      
      overlay.style.left = (stageBox.left + pos.x * stage.scaleX() + stage.x()) + 'px';
      overlay.style.top = (stageBox.top + pos.y * stage.scaleY() + stage.y()) + 'px';
      
      document.body.appendChild(overlay);
      input.focus();
      input.select();
      
      function finishEdit() {
        const label = input.value.trim();
        node.setAttr('label', label);
        
        // Remove existing label text
        const existingLabel = stage.findOne('#' + node.id() + '-label');
        if (existingLabel) existingLabel.destroy();
        
        // Add new label if not empty
        if (label) {
          const labelText = new Konva.Text({
            id: node.id() + '-label',
            x: pos.x,
            y: pos.y - 25,
            text: label,
            fontSize: 14,
            fontFamily: 'Arial',
            fill: '#111827',
            align: 'center',
            listening: false
          });
          
          // Center the label over the shape
          const nodeRect = node.getClientRect();
          labelText.x(nodeRect.x + nodeRect.width/2 - labelText.width()/2);
          
          layer.add(labelText);
        }
        
        layer.draw();
        document.body.removeChild(overlay);
      }
      
      input.addEventListener('blur', finishEdit);
      input.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') finishEdit();
        if (e.key === 'Escape') {
          document.body.removeChild(overlay);
        }
      });
    }

    // --- Connect mode ---
    function handleConnectClick(node) {
      if (!arrowStartNode) {
        arrowStartNode = node;
        // Visual feedback via transformer
        enableTransformer(node);
      } else {
        if (arrowStartNode !== node) {
          createArrow(arrowStartNode, node, currentArrowStyle);
        }
        arrowStartNode = null;
        if (transformer) transformer.destroy();
      }
    }

    function setArrowStyle(style) { currentArrowStyle = style; }

    function getCenterPoint(node) {
      const r = node.getClientRect({ relativeTo: layer });
      return [r.x + r.width/2, r.y + r.height/2];
    }

    function getEdgePoint(fromNode, toNode) {
      const fromRect = fromNode.getClientRect({ relativeTo: layer });
      const toRect = toNode.getClientRect({ relativeTo: layer });
      
      const fromCenter = [fromRect.x + fromRect.width/2, fromRect.y + fromRect.height/2];
      const toCenter = [toRect.x + toRect.width/2, toRect.y + toRect.height/2];
      
      // Calculate angle from center to center
      const angle = Math.atan2(toCenter[1] - fromCenter[1], toCenter[0] - fromCenter[0]);
      
      // Calculate edge points
      const fromEdgeX = fromCenter[0] + (fromRect.width/2) * Math.cos(angle);
      const fromEdgeY = fromCenter[1] + (fromRect.height/2) * Math.sin(angle);
      
      const toEdgeX = toCenter[0] - (toRect.width/2) * Math.cos(angle);
      const toEdgeY = toCenter[1] - (toRect.height/2) * Math.sin(angle);
      
      return [[fromEdgeX, fromEdgeY], [toEdgeX, toEdgeY]];
    }

    function createArrow(fromNode, toNode, style) {
      const [[fx, fy], [tx, ty]] = getEdgePoint(fromNode, toNode);

      const arrowId = nextId('arrow');
      const arrow = new Konva.Arrow({
        id: arrowId,
        points: [fx, fy, tx, ty],
        pointerLength: 10,
        pointerWidth: 10,
        fill: '#111827',
        stroke: '#111827',
        strokeWidth: style === 'bold' ? 5 : 2,
        listening: true // make arrows clickable for labeling
      });

      if (style === 'dashed') arrow.dash([10,5]);
      if (style === 'double') arrow.pointerAtBeginning(true);
      if (style === 'animated') animateArrow(arrow);

      // Add double-click for arrow label editing
      arrow.on('dblclick', (evt) => {
        evt.cancelBubble = true;
        editArrowLabel(arrow);
      });

      layer.add(arrow);
      layer.draw();

      connections.push({
        fromId: fromNode.id(),
        toId: toNode.id(),
        arrowId
      });
    }

    // --- Label editing for arrows ---
    function editArrowLabel(arrow) {
      const points = arrow.points();
      const midX = (points[0] + points[2]) / 2;
      const midY = (points[1] + points[3]) / 2;
      
      const stageBox = stage.container().getBoundingClientRect();
      
      const input = document.createElement('input');
      input.className = 'label-edit-input';
      input.value = arrow.getAttr('label') || '';
      input.placeholder = 'Enter label...';
      
      const overlay = document.createElement('div');
      overlay.className = 'label-edit-overlay';
      overlay.appendChild(input);
      
      overlay.style.left = (stageBox.left + midX * stage.scaleX() + stage.x()) + 'px';
      overlay.style.top = (stageBox.top + midY * stage.scaleY() + stage.y() - 20) + 'px';
      
      document.body.appendChild(overlay);
      input.focus();
      input.select();
      
      function finishEdit() {
        const label = input.value.trim();
        arrow.setAttr('label', label);
        
        // Remove existing label
        const existingLabel = stage.findOne('#' + arrow.id() + '-label');
        if (existingLabel) existingLabel.destroy();
        
        // Add new label if not empty
        if (label) {
          const points = arrow.points();
          const midX = (points[0] + points[2]) / 2;
          const midY = (points[1] + points[3]) / 2;
          
          const labelText = new Konva.Text({
            id: arrow.id() + '-label',
            x: midX,
            y: midY - 15,
            text: label,
            fontSize: 12,
            fontFamily: 'Arial',
            fill: '#111827',
            align: 'center',
            listening: false,
            padding: 4
          });
          
          // Center the label
          labelText.x(midX - labelText.width()/2);
          
          // Add white background rectangle
          const labelBg = new Konva.Rect({
            id: arrow.id() + '-label-bg',
            x: labelText.x() - 4,
            y: labelText.y() - 2,
            width: labelText.width() + 8,
            height: labelText.height() + 4,
            fill: 'white',
            stroke: '#ddd',
            strokeWidth: 1,
            cornerRadius: 3,
            listening: false
          });
          
          layer.add(labelBg);
          layer.add(labelText);
        }
        
        layer.draw();
        document.body.removeChild(overlay);
      }
      
      input.addEventListener('blur', finishEdit);
      input.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') finishEdit();
        if (e.key === 'Escape') {
          document.body.removeChild(overlay);
        }
      });
    }

    function updateConnectionsFor(node) {
      const nid = node.id();
      connections.forEach(conn => {
        if (conn.fromId === nid || conn.toId === nid) {
          const from = stage.findOne('#' + conn.fromId);
          const to = stage.findOne('#' + conn.toId);
          const arr = stage.findOne('#' + conn.arrowId);
          if (from && to && arr) {
            const [[fx, fy], [tx, ty]] = getEdgePoint(from, to);
            arr.points([fx, fy, tx, ty]);
            
            // Update arrow label position
            const label = stage.findOne('#' + conn.arrowId + '-label');
            const labelBg = stage.findOne('#' + conn.arrowId + '-label-bg');
            if (label) {
              const midX = (fx + tx) / 2;
              const midY = (fy + ty) / 2;
              label.position({ x: midX - label.width()/2, y: midY - 15 });
              if (labelBg) {
                labelBg.position({ x: label.x() - 4, y: label.y() - 2 });
              }
            }
          }
        }
      });
      
      // Update node labels (including image labels)
      const nodeLabel = stage.findOne('#' + nid + '-label');
      if (nodeLabel) {
        const nodeRect = node.getClientRect();
        nodeLabel.x(nodeRect.x + nodeRect.width/2 - nodeLabel.width()/2);
        nodeLabel.y(nodeRect.y - 25);
      }
      
      layer.batchDraw();
    }

    function animateArrow(arrow) {
      let dashOffset = 0;
      arrow.dash([15,10]);
      new Konva.Animation(()=>{
        dashOffset -= 2;
        arrow.dashOffset(dashOffset);
      }, layer).start();
    }

    function removeNodeAndConnections(node) {
      // remove related arrows and their labels
      const nid = node.id();
      const toRemove = connections.filter(c => c.fromId === nid || c.toId === nid);
      toRemove.forEach(c => {
        const arr = stage.findOne('#' + c.arrowId);
        const label = stage.findOne('#' + c.arrowId + '-label');
        const labelBg = stage.findOne('#' + c.arrowId + '-label-bg');
        if (arr) arr.destroy();
        if (label) label.destroy();
        if (labelBg) labelBg.destroy();
      });
      connections = connections.filter(c => !(c.fromId === nid || c.toId === nid));

      // remove node label and transformer
      const nodeLabel = stage.findOne('#' + nid + '-label');
      if (nodeLabel) nodeLabel.destroy();
      
      node.destroy();
      if (transformer) transformer.destroy();

      layer.draw();
    }

    // --- Image upload ---
    document.getElementById('imgUpload').addEventListener('change', e=>{
      const file = e.target.files[0]; if(!file) return;
      const reader = new FileReader();
      reader.onload = evt => {
        const img = new Image();
        img.onload = () => {
          const konvaImg = new Konva.Image({
            id: nextId('img'),
            x: 140, y: 260,
            image: img,
            width: Math.min(220, img.width),
            height: Math.min(220 * (img.height / img.width), img.height)
          });
          makeSelectableAndDraggable(konvaImg);
        };
        img.src = evt.target.result;
      };
      reader.readAsDataURL(file);
      // reset input so same file can be chosen again
      e.target.value = '';
    });

    // --- Export ---
    function exportPNG() {
      const dataURL = stage.toDataURL({ mimeType: 'image/png', pixelRatio: 2 });
      downloadURI(dataURL, 'flowchart.png');
    }

    function exportSVG() {
      // Create a comprehensive SVG export including all labels
      const stageClone = stage.clone();
      
      // Get all the data we need before generating SVG
      const stageData = {
        width: stage.width(),
        height: stage.height(),
        nodes: [],
        arrows: [],
        labels: []
      };
      
      // Collect node data
      stage.find('Rect, Circle, RegularPolygon, Line, Image').forEach(node => {
        const rect = node.getClientRect();
        const nodeData = {
          id: node.id(),
          type: node.getClassName(),
          x: rect.x,
          y: rect.y,
          width: rect.width,
          height: rect.height,
          fill: node.fill(),
          stroke: node.stroke(),
          strokeWidth: node.strokeWidth(),
          label: node.getAttr('label') || ''
        };
        
        if (node.getClassName() === 'RegularPolygon') {
          nodeData.sides = node.sides();
          nodeData.radius = node.radius();
          nodeData.rotation = node.rotation();
        }
        
        stageData.nodes.push(nodeData);
      });
      
      // Collect arrow data
      stage.find('Arrow').forEach(arrow => {
        const points = arrow.points();
        stageData.arrows.push({
          id: arrow.id(),
          points: points,
          stroke: arrow.stroke(),
          strokeWidth: arrow.strokeWidth(),
          dash: arrow.dash(),
          label: arrow.getAttr('label') || ''
        });
      });
      
      // Generate custom SVG with proper labels
      let svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${stageData.width}" height="${stageData.height}" viewBox="0 0 ${stageData.width} ${stageData.height}">`;
      
      // Add styles
      svg += `<style>
        .node-label { font-family: Arial, sans-serif; font-size: 14px; fill: #111827; text-anchor: middle; }
        .arrow-label { font-family: Arial, sans-serif; font-size: 12px; fill: #111827; text-anchor: middle; }
        .label-bg { fill: white; stroke: #ddd; stroke-width: 1; }
      </style>`;
      
      // Add nodes
      stageData.nodes.forEach(node => {
        if (node.type === 'Rect') {
          svg += `<rect x="${node.x}" y="${node.y}" width="${node.width}" height="${node.height}" fill="${node.fill}" stroke="${node.stroke}" stroke-width="${node.strokeWidth}"/>`;
        } else if (node.type === 'Circle') {
          const cx = node.x + node.width/2;
          const cy = node.y + node.height/2;
          const r = node.width/2;
          svg += `<circle cx="${cx}" cy="${cy}" r="${r}" fill="${node.fill}" stroke="${node.stroke}" stroke-width="${node.strokeWidth}"/>`;
        } else if (node.type === 'RegularPolygon') {
          const cx = node.x + node.width/2;
          const cy = node.y + node.height/2;
          const points = [];
          for (let i = 0; i < node.sides; i++) {
            const angle = (i * 2 * Math.PI / node.sides) + (node.rotation * Math.PI / 180);
            const x = cx + node.radius * Math.cos(angle);
            const y = cy + node.radius * Math.sin(angle);
            points.push(`${x},${y}`);
          }
          svg += `<polygon points="${points.join(' ')}" fill="${node.fill}" stroke="${node.stroke}" stroke-width="${node.strokeWidth}"/>`;
        }
        
        // Add node label
        if (node.label) {
          const labelX = node.x + node.width/2;
          const labelY = node.y - 8;
          svg += `<text x="${labelX}" y="${labelY}" class="node-label">${node.label}</text>`;
        }
      });
      
      // Add arrows
      stageData.arrows.forEach(arrow => {
        const points = arrow.points;
        const dashArray = arrow.dash ? `stroke-dasharray="${arrow.dash.join(',')}"` : '';
        
        svg += `<line x1="${points[0]}" y1="${points[1]}" x2="${points[2]}" y2="${points[3]}" stroke="${arrow.stroke}" stroke-width="${arrow.strokeWidth}" ${dashArray} marker-end="url(#arrowhead)"/>`;
        
        // Add arrow label with background
        if (arrow.label) {
          const midX = (points[0] + points[2]) / 2;
          const midY = (points[1] + points[3]) / 2;
          const textWidth = arrow.label.length * 7; // Approximate text width
          
          svg += `<rect x="${midX - textWidth/2 - 4}" y="${midY - 17}" width="${textWidth + 8}" height="18" class="label-bg" rx="3"/>`;
          svg += `<text x="${midX}" y="${midY - 6}" class="arrow-label">${arrow.label}</text>`;
        }
      });
      
      // Add arrow marker definition
      svg += `<defs>
        <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
          <polygon points="0 0, 10 3.5, 0 7" fill="#111827"/>
        </marker>
      </defs>`;
      
      svg += '</svg>';
      
      const blob = new Blob([svg], { type:'image/svg+xml' });
      downloadURI(URL.createObjectURL(blob), 'flowchart.svg');
    }

    async function exportPDF() {
      const { jsPDF } = window.jspdf;
      const pdf = new jsPDF({ orientation: 'landscape', unit: 'pt', format: 'a4' });
      const padding = 24;
      const w = pdf.internal.pageSize.getWidth() - padding*2;
      const h = pdf.internal.pageSize.getHeight() - padding*2;
      const dataURL = stage.toDataURL({ pixelRatio: 2 });
      pdf.addImage(dataURL, 'PNG', padding, padding, w, h);
      pdf.save('flowchart.pdf');
    }

    function exportJSON() {
      // include our connection map so links work after import
      const payload = {
        konva: stage.toJSON(),
        connections
      };
      const blob = new Blob([JSON.stringify(payload)], { type: 'application/json' });
      downloadURI(URL.createObjectURL(blob), 'flowchart.json');
    }

    document.getElementById('importJson').addEventListener('change', e=>{
      const file = e.target.files[0]; if(!file) return;
      const reader = new FileReader();
      reader.onload = evt => {
        const payload = JSON.parse(evt.target.result);

        // Rebuild stage
        initStage();
        const newLayerTree = Konva.Node.create(payload.konva, 'container');

        // Attach behavior to selectable nodes (including images)
        stage.find('Rect, Circle, RegularPolygon, Line, Image').each(n => {
          if (!n.id()) n.id(nextId('node'));
          makeSelectableAndDraggable(n);
        });

        // Restore connections and attach label editing to arrows
        connections = Array.isArray(payload.connections) ? payload.connections : [];
        const rebuilt = [];
        connections.forEach(c => {
          let arr = stage.findOne('#' + c.arrowId);
          const from = stage.findOne('#' + c.fromId);
          const to = stage.findOne('#' + c.toId);
          if (from && to) {
            if (!arr) {
              const [[fx, fy], [tx, ty]] = getEdgePoint(from, to);
              arr = new Konva.Arrow({
                id: c.arrowId,
                points: [fx, fy, tx, ty],
                pointerLength: 10, pointerWidth: 10,
                fill: '#111827', stroke: '#111827', strokeWidth: 2, listening: true
              });
              layer.add(arr);
              arr.moveToBottom();
            }
            // Add double-click for label editing
            arr.on('dblclick', (evt) => {
              evt.cancelBubble = true;
              editArrowLabel(arr);
            });
            rebuilt.push(c);
          }
        });
        connections = rebuilt;

        layer.draw();
      };
      reader.readAsText(file);
      e.target.value = '';
    });

    function downloadURI(uri, name) {
      const link = document.createElement('a');
      link.download = name;
      link.href = uri;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }

    // --- UI controls ---
    modeBtn.addEventListener('click', () => {
      isConnectMode = !isConnectMode;
      modeText.textContent = `Connect Mode: ${isConnectMode ? 'On' : 'Off'}`;
      modeBtn.classList.toggle('btn-primary', isConnectMode);
      modeBtn.classList.toggle('btn-outline-light', !isConnectMode);
      arrowStartNode = null;
      if (transformer) transformer.destroy();
    });

    document.getElementById('zoomInBtn').addEventListener('click', () => zoomBy(1.15));
    document.getElementById('zoomOutBtn').addEventListener('click', () => zoomBy(1/1.15));
    document.getElementById('resetViewBtn').addEventListener('click', () => {
      stage.position({ x: 0, y: 0 });
      stage.scale({ x: 1, y: 1 });
      stage.batchDraw();
    });

    function zoomBy(factor) {
      const oldScale = stage.scaleX();
      const center = { x: stage.width()/2, y: stage.height()/2 };
      const pointer = {
        x: (center.x - stage.x()) / oldScale,
        y: (center.y - stage.y()) / oldScale
      };
      const newScale = oldScale * factor;
      stage.scale({ x: newScale, y: newScale });
      const newPos = {
        x: center.x - pointer.x * newScale,
        y: center.y - pointer.y * newScale
      };
      stage.position(newPos);
      stage.batchDraw();
    }

    // --- Boot ---
    function boot() {
      // size canvas area based on layout
      const resizeCanvas = () => {
        const topbarH = document.querySelector('.topbar').getBoundingClientRect().height;
        const sidebarW = document.getElementById('sidebar').getBoundingClientRect().width;
        canvasWrap.style.height = `calc(100vh - ${topbarH}px)`;
        canvasWrap.style.width = `calc(100vw - ${sidebarW}px)`;
        if (stage) {
          stage.size({ width: canvasWrap.clientWidth, height: canvasWrap.clientHeight });
          if (background) background.size({ width: stage.width(), height: stage.height() });
          layer?.batchDraw();
        }
      };
      window.addEventListener('resize', resizeCanvas);
      resizeCanvas();

      initStage();
    }

    boot();
  </script>
  
</body>
</html>